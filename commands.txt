-- notes here should be all chronological, maybe not all, but almost --

conda
- conda create -n hidjango python=3.8
- conda activate hidjango (switching env actually do not require 'deactivate')
- conda install PACKAGE_NAME

initial setup
- django-admin startproject PROJECT
- django-admin startapp     APP
- ./manage.py migrate
- ./manage.py createsuperuser   (strong password recommended)
- ./manage.py runserver IP:PORT (e.g. localhost:8899)

main project vs apps
- a project is a folder containing all the stuff (apps, settings, templates ..)
- an app    is a folder within a (django) project, it does one specific thing

template folder (where to find for Django)
- PROJECT/PROJECT/settings.py
    - `TEMPLATES -> [ { DIRS: [ os.path.join(BASE_DIR, 'templates') ]  }  ]`

a sample index page (class-based view)
- views.py -> from django.views.generic import XxxView .. class YyyView(..): ..
- urls.py  -> .. import the view, path('PATH', VIEW, name='index'),
- PLUS, path like ''(root) should be put to the last one, it's a MUST :P

passing context data to templates
- It's pretty obvious when using function-based views, you simply use a dict
- In class-based views, you need to write like this
    ```python3
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs):
        context['VARIABLE_NAME'] = THE_VALUE  # can be dynamic or else
        return context
    ```

calling *view* methods in templates (steps below were based on class-based views)
- usage
    - simply type `view.METHOD_NAME`, no `()` required :P
    - why `view.`? see
        - `lib/python3.8/site-packages/django/views/generic/base.py :: Line 72/73`
- how-to
    - nothing special, `def METHOD(self): ... # return something`


----------------- THIS IS ANOTHER PROJECT: everycheese ------------------

initial setup
- create a new env, activate it, install packages
    - conda create -n everycheese python=3.8
    - conda install -c conda-forge cookiecutter
    - mkdir everycheese && cd everycheese (in case other stuff messed up the root)
- generate a project using `cookiecutter`
    - cookiecutter gh:roygreenfeld/django-crash-starter
        > the name of the folder created'd be the *slug* part you specified
- database setup (postgreSQL)
    - new role: createuser -dP everycheeseboss
    - new database: createdb -E utf-8 -U everycheeseboss everycheese
    - modify the default database URL
        - first put the URL in a `.env` (for safety purposes)
            - e.g. `postgres://ROLE:ROLE_PASSWORD@localhost:5432/DATABASE_NAME
            - reference: https://stackoverflow.com/questions/3582552/postgresql-connection-url
        - simply change the KEY (defined in the .env file)
            - config/settings/base.py -> DATABASES -> { .. env.db("KEY", ..) }
- installing required packages
    - first make sure the virutal environment is on (conda activate everycheese)
    - pip install -r requirements/local.txt (it might take a while to install :P)
- finish up the basic part
   - ./manage.py migrate
   - ./manage.py createsuperuser
   - ./manage.py runserver localhost:8899

- adding new field 'bio'
    - models.py: `bio = models.TextField(_("Bio"), blank=True)`
        - ./manage.py makemigrations users
        - ./manage.py migrate users
    - views.py
        - add `'bio'` to the `fields` in the `UserUpdateView`, the rest would be handled by `UpdateView`
    - templates: user_edit.html
        ```html
        {% if object.name %}
            <p>{{ object.name }}</p>
            <p>{{ object.bio|linebreaksbr }}</p>  <!-- the line we need to add -->
        {% endif %}
        ```
- examine the pre-written tests
    - tips
        - write tests for **every single model methods** (code stability boosted!)
    - commands that were used
        - `coverage run -m pytest`
        - `coverage report`
        - `coverage html` (does the same as `report` but exists as HTML files)  
    - more
        - almost all of the questions could answered in the docs & source code :P
